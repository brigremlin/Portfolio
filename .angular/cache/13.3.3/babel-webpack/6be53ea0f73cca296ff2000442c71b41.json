{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, ViewEncapsulation, Input, HostBinding, NgModule, HostListener, ViewChild, Pipe, Output, Directive, ContentChildren } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { Subject, fromEvent, Observable, combineLatest, timer } from 'rxjs';\nimport { map } from 'rxjs/operators';\nconst _c0 = [\"*\"];\nconst _c1 = [\"volumeBar\"];\n\nconst _c2 = function (a0) {\n  return {\n    dragging: a0\n  };\n};\n\nfunction VgScrubBarCuePoints_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 2);\n  }\n\n  if (rf & 2) {\n    const cp_r1 = ctx.$implicit;\n    i0.ɵɵstyleProp(\"width\", cp_r1.$$style == null ? null : cp_r1.$$style.width)(\"left\", cp_r1.$$style == null ? null : cp_r1.$$style.left);\n  }\n}\n\nfunction VgScrubBarCurrentTime_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 2);\n  }\n}\n\nfunction VgTimeDisplay_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1, \"LIVE\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction VgTimeDisplay_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"vgUtc\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(2, 1, ctx_r1.getTime(), ctx_r1.vgFormat));\n  }\n}\n\nfunction VgTrackSelector_option_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"option\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const track_r1 = ctx.$implicit;\n    i0.ɵɵproperty(\"value\", track_r1.id)(\"selected\", track_r1.selected === true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", track_r1.label, \" \");\n  }\n}\n\nfunction VgQualitySelector_option_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"option\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const bitrate_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", bitrate_r1.qualityIndex.toString())(\"selected\", bitrate_r1.qualityIndex === (ctx_r0.bitrateSelected == null ? null : ctx_r0.bitrateSelected.qualityIndex));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", bitrate_r1.label, \" \");\n  }\n}\n\nlet VgStates = /*#__PURE__*/(() => {\n  class VgStates {}\n\n  VgStates.VG_ENDED = 'ended';\n  VgStates.VG_PAUSED = 'paused';\n  VgStates.VG_PLAYING = 'playing';\n  VgStates.VG_LOADING = 'waiting';\n\n  VgStates.ɵfac = function VgStates_Factory(t) {\n    return new (t || VgStates)();\n  };\n\n  VgStates.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: VgStates,\n    factory: VgStates.ɵfac\n  });\n  return VgStates;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgAPI = /*#__PURE__*/(() => {\n  class VgAPI {\n    constructor() {\n      // tslint:disable-next-line:ban-types\n      this.medias = {}; // TODO: refactor to Set<IPlayable>\n\n      this.playerReadyEvent = new EventEmitter(true);\n      this.isPlayerReady = false;\n    }\n\n    onPlayerReady(fsAPI) {\n      this.fsAPI = fsAPI;\n      this.isPlayerReady = true;\n      this.playerReadyEvent.emit(this);\n    }\n\n    getDefaultMedia() {\n      for (const item in this.medias) {\n        if (this.medias[item]) {\n          return this.medias[item];\n        }\n      }\n    }\n\n    getMasterMedia() {\n      let master;\n\n      for (const id in this.medias) {\n        if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {\n          master = this.medias[id];\n          break;\n        }\n      }\n\n      return master || this.getDefaultMedia();\n    }\n\n    isMasterDefined() {\n      let result = false;\n\n      for (const id in this.medias) {\n        if (this.medias[id].vgMaster === 'true' || this.medias[id].vgMaster === true) {\n          result = true;\n          break;\n        }\n      }\n\n      return result;\n    }\n\n    getMediaById(id = null) {\n      let media = this.medias[id];\n\n      if (!id || id === '*') {\n        media = this;\n      }\n\n      return media;\n    }\n\n    play() {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.medias[id].play();\n        }\n      }\n    }\n\n    pause() {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.medias[id].pause();\n        }\n      }\n    }\n\n    get duration() {\n      return this.$$getAllProperties('duration');\n    }\n\n    set currentTime(seconds) {\n      this.$$setAllProperties('currentTime', seconds);\n    }\n\n    get currentTime() {\n      return this.$$getAllProperties('currentTime');\n    }\n\n    set state(state) {\n      this.$$setAllProperties('state', state);\n    }\n\n    get state() {\n      return this.$$getAllProperties('state');\n    }\n\n    set volume(volume) {\n      this.$$setAllProperties('volume', volume);\n    }\n\n    get volume() {\n      return this.$$getAllProperties('volume');\n    }\n\n    set playbackRate(rate) {\n      this.$$setAllProperties('playbackRate', rate);\n    }\n\n    get playbackRate() {\n      return this.$$getAllProperties('playbackRate');\n    }\n\n    get canPlay() {\n      return this.$$getAllProperties('canPlay');\n    }\n\n    get canPlayThrough() {\n      return this.$$getAllProperties('canPlayThrough');\n    }\n\n    get isMetadataLoaded() {\n      return this.$$getAllProperties('isMetadataLoaded');\n    }\n\n    get isWaiting() {\n      return this.$$getAllProperties('isWaiting');\n    }\n\n    get isCompleted() {\n      return this.$$getAllProperties('isCompleted');\n    }\n\n    get isLive() {\n      return this.$$getAllProperties('isLive');\n    }\n\n    get isMaster() {\n      return this.$$getAllProperties('isMaster');\n    }\n\n    get time() {\n      return this.$$getAllProperties('time');\n    }\n\n    get buffer() {\n      return this.$$getAllProperties('buffer');\n    }\n\n    get buffered() {\n      return this.$$getAllProperties('buffered');\n    }\n\n    get subscriptions() {\n      return this.$$getAllProperties('subscriptions');\n    }\n\n    get textTracks() {\n      return this.$$getAllProperties('textTracks');\n    }\n\n    seekTime(value, byPercent = false) {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.$$seek(this.medias[id], value, byPercent);\n        }\n      }\n    }\n\n    $$seek(media, value, byPercent = false) {\n      let second;\n      let duration = media.duration;\n\n      if (byPercent) {\n        if (this.isMasterDefined()) {\n          duration = this.getMasterMedia().duration;\n        }\n\n        second = value * duration / 100;\n      } else {\n        second = value;\n      }\n\n      media.currentTime = second;\n    }\n\n    addTextTrack(type, label, language) {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.$$addTextTrack(this.medias[id], type, label, language);\n        }\n      }\n    }\n\n    $$addTextTrack(media, type, label, language) {\n      media.addTextTrack(type, label, language);\n    }\n\n    $$getAllProperties(property) {\n      const medias = {};\n      let result;\n\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          medias[id] = this.medias[id];\n        }\n      }\n\n      const nMedias = Object.keys(medias).length;\n\n      switch (nMedias) {\n        case 0:\n          // Return default values until vgMedia is initialized\n          switch (property) {\n            case 'state':\n              result = VgStates.VG_PAUSED;\n              break;\n\n            case 'playbackRate':\n            case 'volume':\n              result = 1;\n              break;\n\n            case 'time':\n              result = {\n                current: 0,\n                total: 0,\n                left: 0\n              };\n              break;\n          }\n\n          break;\n\n        case 1:\n          // If there's only one media element then return the plain value\n          const firstMediaId = Object.keys(medias)[0];\n          result = medias[firstMediaId][property];\n          break;\n\n        default:\n          // TODO: return 'master' value\n          const master = this.getMasterMedia();\n          result = medias[master.id][property];\n      }\n\n      return result;\n    }\n\n    $$setAllProperties(property, value) {\n      for (const id in this.medias) {\n        if (this.medias[id]) {\n          this.medias[id][property] = value;\n        }\n      }\n    }\n\n    registerElement(elem) {\n      this.videogularElement = elem;\n    }\n\n    registerMedia(media) {\n      this.medias[media.id] = media;\n    }\n\n    unregisterMedia(media) {\n      delete this.medias[media.id];\n    }\n\n  }\n\n  VgAPI.ɵfac = function VgAPI_Factory(t) {\n    return new (t || VgAPI)();\n  };\n\n  VgAPI.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: VgAPI,\n    factory: VgAPI.ɵfac\n  });\n  return VgAPI;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgBuffering = /*#__PURE__*/(() => {\n  class VgBuffering {\n    constructor(ref, API) {\n      this.API = API;\n      this.checkInterval = 50;\n      this.currentPlayPos = 0;\n      this.lastPlayPos = 0;\n      this.subscriptions = [];\n      this.isBuffering = false;\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.subscriptions.push(this.target.subscriptions.bufferDetected.subscribe(isBuffering => this.onUpdateBuffer(isBuffering)));\n    }\n\n    onUpdateBuffer(isBuffering) {\n      this.isBuffering = isBuffering;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgBuffering.ɵfac = function VgBuffering_Factory(t) {\n    return new (t || VgBuffering)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgBuffering.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgBuffering,\n    selectors: [[\"vg-buffering\"]],\n    hostVars: 2,\n    hostBindings: function VgBuffering_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"is-buffering\", ctx.isBuffering);\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 3,\n    vars: 0,\n    consts: [[1, \"vg-buffering\"], [1, \"bufferingContainer\"], [1, \"loadingSpinner\"]],\n    template: function VgBuffering_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵelement(2, \"div\", 2);\n        i0.ɵɵelementEnd()();\n      }\n    },\n    styles: [\"vg-buffering{display:none;z-index:201}vg-buffering.is-buffering{display:block}.vg-buffering{position:absolute;display:block;width:100%;height:100%}.vg-buffering .bufferingContainer{width:100%;position:absolute;cursor:pointer;top:50%;margin-top:-50px;zoom:1;filter:alpha(opacity=60);opacity:.6}.vg-buffering .loadingSpinner{background-color:#0000;border:5px solid rgba(255,255,255,1);opacity:.9;border-top:5px solid rgba(0,0,0,0);border-left:5px solid rgba(0,0,0,0);border-radius:50px;box-shadow:0 0 35px #fff;width:50px;height:50px;margin:0 auto;-moz-animation:spin .5s infinite linear;-webkit-animation:spin .5s infinite linear}.vg-buffering .loadingSpinner .stop{-webkit-animation-play-state:paused;-moz-animation-play-state:paused}\\n\"],\n    encapsulation: 2\n  });\n  return VgBuffering;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgBufferingModule = /*#__PURE__*/(() => {\n  class VgBufferingModule {}\n\n  VgBufferingModule.ɵfac = function VgBufferingModule_Factory(t) {\n    return new (t || VgBufferingModule)();\n  };\n\n  VgBufferingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: VgBufferingModule\n  });\n  VgBufferingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return VgBufferingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgControlsHidden = /*#__PURE__*/(() => {\n  class VgControlsHidden {\n    constructor() {\n      this.isHiddenSubject = new Subject();\n      this.isHidden = this.isHiddenSubject.asObservable();\n    }\n\n    state(hidden) {\n      this.isHiddenSubject.next(hidden);\n    }\n\n  }\n\n  VgControlsHidden.ɵfac = function VgControlsHidden_Factory(t) {\n    return new (t || VgControlsHidden)();\n  };\n\n  VgControlsHidden.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: VgControlsHidden,\n    factory: VgControlsHidden.ɵfac\n  });\n  return VgControlsHidden;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgControls = /*#__PURE__*/(() => {\n  class VgControls {\n    constructor(API, ref, hidden) {\n      this.API = API;\n      this.ref = ref;\n      this.hidden = hidden;\n      this.isAdsPlaying = 'initial';\n      this.hideControls = false;\n      this.vgAutohide = false;\n      this.vgAutohideTime = 3;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      this.mouseMove$ = fromEvent(this.API.videogularElement, 'mousemove');\n      this.subscriptions.push(this.mouseMove$.subscribe(this.show.bind(this)));\n      this.touchStart$ = fromEvent(this.API.videogularElement, 'touchstart');\n      this.subscriptions.push(this.touchStart$.subscribe(this.show.bind(this)));\n\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.subscriptions.push(this.target.subscriptions.play.subscribe(this.onPlay.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.pause.subscribe(this.onPause.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.startAds.subscribe(this.onStartAds.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.endAds.subscribe(this.onEndAds.bind(this)));\n    }\n\n    ngAfterViewInit() {\n      if (this.vgAutohide) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    onPlay() {\n      if (this.vgAutohide) {\n        this.hide();\n      }\n    }\n\n    onPause() {\n      clearTimeout(this.timer);\n      this.hideControls = false;\n      this.hidden.state(false);\n    }\n\n    onStartAds() {\n      this.isAdsPlaying = 'none';\n    }\n\n    onEndAds() {\n      this.isAdsPlaying = 'initial';\n    }\n\n    hide() {\n      if (this.vgAutohide) {\n        clearTimeout(this.timer);\n        this.hideAsync();\n      }\n    }\n\n    show() {\n      clearTimeout(this.timer);\n      this.hideControls = false;\n      this.hidden.state(false);\n\n      if (this.vgAutohide) {\n        this.hideAsync();\n      }\n    }\n\n    hideAsync() {\n      if (this.API.state === VgStates.VG_PLAYING) {\n        this.timer = setTimeout(() => {\n          this.hideControls = true;\n          this.hidden.state(true);\n        }, this.vgAutohideTime * 1000);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgControls.ɵfac = function VgControls_Factory(t) {\n    return new (t || VgControls)(i0.ɵɵdirectiveInject(VgAPI), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgControlsHidden));\n  };\n\n  VgControls.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgControls,\n    selectors: [[\"vg-controls\"]],\n    hostVars: 4,\n    hostBindings: function VgControls_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"pointer-events\", ctx.isAdsPlaying);\n        i0.ɵɵclassProp(\"hide\", ctx.hideControls);\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\",\n      vgAutohide: \"vgAutohide\",\n      vgAutohideTime: \"vgAutohideTime\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function VgControls_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"vg-controls{position:absolute;display:flex;width:100%;height:50px;z-index:300;bottom:0;background-color:#00000080;transition:bottom 1s}vg-controls.hide{bottom:-50px}\\n\"],\n    encapsulation: 2\n  });\n  return VgControls;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgUtils = /*#__PURE__*/(() => {\n  class VgUtils {\n    /**\n     * Inspired by Paul Irish\n     * https://gist.github.com/paulirish/211209\n     * @returns z-Index\n     */\n    static getZIndex() {\n      let zIndex = 1;\n      let elementZIndex;\n      const tags = document.getElementsByTagName('*');\n\n      for (let i = 0, l = tags.length; i < l; i++) {\n        elementZIndex = parseInt(window.getComputedStyle(tags[i])['z-index'], 10);\n\n        if (elementZIndex > zIndex) {\n          zIndex = elementZIndex + 1;\n        }\n      }\n\n      return zIndex;\n    } // Very simple mobile detection, not 100% reliable\n\n\n    static isMobileDevice() {\n      return typeof window.orientation !== 'undefined' || navigator.userAgent.indexOf('IEMobile') !== -1;\n    }\n\n    static isiOSDevice() {\n      return navigator.userAgent.match(/ip(hone|ad|od)/i) && !navigator.userAgent.match(/(iemobile)[\\/\\s]?([\\w\\.]*)/i);\n    }\n\n    static isCordova() {\n      return document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;\n    }\n\n  }\n\n  VgUtils.ɵfac = function VgUtils_Factory(t) {\n    return new (t || VgUtils)();\n  };\n\n  VgUtils.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: VgUtils,\n    factory: VgUtils.ɵfac,\n    providedIn: 'root'\n  });\n  return VgUtils;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgFullscreenAPI = /*#__PURE__*/(() => {\n  class VgFullscreenAPI {\n    constructor() {\n      this.nativeFullscreen = true;\n      this.isFullscreen = false;\n      this.onChangeFullscreen = new EventEmitter();\n    }\n\n    init(elem, medias) {\n      this.videogularElement = elem;\n      this.medias = medias;\n      const APIs = {\n        w3: {\n          enabled: 'fullscreenEnabled',\n          element: 'fullscreenElement',\n          request: 'requestFullscreen',\n          exit: 'exitFullscreen',\n          onchange: 'fullscreenchange',\n          onerror: 'fullscreenerror'\n        },\n        newWebkit: {\n          enabled: 'webkitFullscreenEnabled',\n          element: 'webkitFullscreenElement',\n          request: 'webkitRequestFullscreen',\n          exit: 'webkitExitFullscreen',\n          onchange: 'webkitfullscreenchange',\n          onerror: 'webkitfullscreenerror'\n        },\n        oldWebkit: {\n          enabled: 'webkitIsFullScreen',\n          element: 'webkitCurrentFullScreenElement',\n          request: 'webkitRequestFullScreen',\n          exit: 'webkitCancelFullScreen',\n          onchange: 'webkitfullscreenchange',\n          onerror: 'webkitfullscreenerror'\n        },\n        moz: {\n          enabled: 'mozFullScreen',\n          element: 'mozFullScreenElement',\n          request: 'mozRequestFullScreen',\n          exit: 'mozCancelFullScreen',\n          onchange: 'mozfullscreenchange',\n          onerror: 'mozfullscreenerror'\n        },\n        ios: {\n          enabled: 'webkitFullscreenEnabled',\n          element: 'webkitFullscreenElement',\n          request: 'webkitEnterFullscreen',\n          exit: 'webkitExitFullscreen',\n          onchange: 'webkitendfullscreen',\n          onerror: 'webkitfullscreenerror'\n        },\n        ms: {\n          enabled: 'msFullscreenEnabled',\n          element: 'msFullscreenElement',\n          request: 'msRequestFullscreen',\n          exit: 'msExitFullscreen',\n          onchange: 'MSFullscreenChange',\n          onerror: 'MSFullscreenError'\n        }\n      };\n\n      for (const browser in APIs) {\n        if (APIs[browser].enabled in document) {\n          this.polyfill = APIs[browser];\n          break;\n        }\n      }\n\n      if (VgUtils.isiOSDevice()) {\n        this.polyfill = APIs.ios;\n      }\n\n      this.isAvailable = this.polyfill != null;\n\n      if (this.polyfill == null) {\n        return;\n      }\n\n      let fsElemDispatcher;\n\n      switch (this.polyfill.onchange) {\n        // Mozilla dispatches the fullscreen change event from document, not the element\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=724816#c3\n        case 'mozfullscreenchange':\n          fsElemDispatcher = document;\n          break;\n        // iOS dispatches the fullscreen change event from video element\n\n        case 'webkitendfullscreen':\n          fsElemDispatcher = this.medias.toArray()[0].elem;\n          break;\n        // HTML5 implementation dispatches the fullscreen change event from the element\n\n        default:\n          fsElemDispatcher = elem;\n      }\n\n      this.fsChangeSubscription = fromEvent(fsElemDispatcher, this.polyfill.onchange).subscribe(() => {\n        this.onFullscreenChange();\n      });\n    }\n\n    onFullscreenChange() {\n      this.isFullscreen = !!document[this.polyfill.element];\n      this.onChangeFullscreen.emit(this.isFullscreen);\n    }\n\n    toggleFullscreen(element = null) {\n      if (this.isFullscreen) {\n        this.exit();\n      } else {\n        this.request(element);\n      }\n    }\n\n    request(elem) {\n      if (!elem) {\n        elem = this.videogularElement;\n      }\n\n      this.isFullscreen = true;\n      this.onChangeFullscreen.emit(true); // Perform native full screen support\n\n      if (this.isAvailable && this.nativeFullscreen) {\n        // Fullscreen for mobile devices\n        if (VgUtils.isMobileDevice()) {\n          // We should make fullscreen the video object if it doesn't have native fullscreen support\n          // Fallback! We can't set vg-player on fullscreen, only video/audio objects\n          if (!this.polyfill.enabled && elem === this.videogularElement || VgUtils.isiOSDevice()) {\n            elem = this.medias.toArray()[0].elem;\n          }\n\n          this.enterElementInFullScreen(elem);\n        } else {\n          this.enterElementInFullScreen(this.videogularElement);\n        }\n      }\n    }\n\n    enterElementInFullScreen(elem) {\n      elem[this.polyfill.request]();\n    }\n\n    exit() {\n      this.isFullscreen = false;\n      this.onChangeFullscreen.emit(false); // Exit from native fullscreen\n\n      if (this.isAvailable && this.nativeFullscreen) {\n        document[this.polyfill.exit]();\n      }\n    }\n\n  }\n\n  VgFullscreenAPI.ɵfac = function VgFullscreenAPI_Factory(t) {\n    return new (t || VgFullscreenAPI)();\n  };\n\n  VgFullscreenAPI.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: VgFullscreenAPI,\n    factory: VgFullscreenAPI.ɵfac\n  });\n  return VgFullscreenAPI;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n// tslint:disable:ban-types\n\n\nlet VgFullscreen = /*#__PURE__*/(() => {\n  class VgFullscreen {\n    constructor(ref, API, fsAPI) {\n      this.API = API;\n      this.fsAPI = fsAPI;\n      this.isFullscreen = false;\n      this.subscriptions = [];\n      this.ariaValue = 'normal mode';\n      this.elem = ref.nativeElement;\n      this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    onChangeFullscreen(fsState) {\n      this.ariaValue = fsState ? 'fullscren mode' : 'normal mode';\n      this.isFullscreen = fsState;\n    }\n\n    onClick() {\n      this.changeFullscreenState();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.changeFullscreenState();\n      }\n    }\n\n    changeFullscreenState() {\n      let element = this.target;\n\n      if (this.target instanceof VgAPI) {\n        element = null;\n      }\n\n      this.fsAPI.toggleFullscreen(element);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgFullscreen.ɵfac = function VgFullscreen_Factory(t) {\n    return new (t || VgFullscreen)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI), i0.ɵɵdirectiveInject(VgFullscreenAPI));\n  };\n\n  VgFullscreen.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgFullscreen,\n    selectors: [[\"vg-fullscreen\"]],\n    hostBindings: function VgFullscreen_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function VgFullscreen_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgFullscreen_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    decls: 1,\n    vars: 5,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", \"aria-label\", \"fullscreen button\", 1, \"icon\"]],\n    template: function VgFullscreen_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"vg-icon-fullscreen\", !ctx.isFullscreen)(\"vg-icon-fullscreen_exit\", ctx.isFullscreen);\n        i0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n      }\n    },\n    styles: [\"vg-fullscreen{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;height:50px;width:50px;cursor:pointer;color:#fff;line-height:50px}vg-fullscreen .icon{pointer-events:none}\\n\"],\n    encapsulation: 2\n  });\n  return VgFullscreen;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgMute = /*#__PURE__*/(() => {\n  class VgMute {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.ariaValue = 'unmuted';\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.currentVolume = this.target.volume;\n    }\n\n    onClick() {\n      this.changeMuteState();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.changeMuteState();\n      }\n    }\n\n    changeMuteState() {\n      const volume = this.getVolume();\n\n      if (volume === 0) {\n        if (this.target.volume === 0 && this.currentVolume === 0) {\n          this.currentVolume = 1;\n        }\n\n        this.target.volume = this.currentVolume;\n      } else {\n        this.currentVolume = volume;\n        this.target.volume = 0;\n      }\n    }\n\n    getVolume() {\n      const volume = this.target ? this.target.volume : 0;\n      this.ariaValue = volume ? 'unmuted' : 'muted';\n      return volume;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgMute.ɵfac = function VgMute_Factory(t) {\n    return new (t || VgMute)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgMute.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgMute,\n    selectors: [[\"vg-mute\"]],\n    hostBindings: function VgMute_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function VgMute_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgMute_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 1,\n    vars: 9,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", \"aria-label\", \"mute button\", 1, \"icon\"]],\n    template: function VgMute_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"vg-icon-volume_up\", ctx.getVolume() >= 0.75)(\"vg-icon-volume_down\", ctx.getVolume() >= 0.25 && ctx.getVolume() < 0.75)(\"vg-icon-volume_mute\", ctx.getVolume() > 0 && ctx.getVolume() < 0.25)(\"vg-icon-volume_off\", ctx.getVolume() === 0);\n        i0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n      }\n    },\n    styles: [\"vg-mute{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;height:50px;width:50px;cursor:pointer;color:#fff;line-height:50px}vg-mute .icon{pointer-events:none}\\n\"],\n    encapsulation: 2\n  });\n  return VgMute;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgVolume = /*#__PURE__*/(() => {\n  class VgVolume {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n      this.isDragging = false;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.ariaValue = this.getVolume() * 100;\n    }\n\n    onClick(event) {\n      this.setVolume(this.calculateVolume(event.clientX));\n    }\n\n    onMouseDown(event) {\n      this.mouseDownPosX = event.clientX;\n      this.isDragging = true;\n    }\n\n    onDrag(event) {\n      if (this.isDragging) {\n        this.setVolume(this.calculateVolume(event.clientX));\n      }\n    }\n\n    onStopDrag(event) {\n      if (this.isDragging) {\n        this.isDragging = false;\n\n        if (this.mouseDownPosX === event.clientX) {\n          this.setVolume(this.calculateVolume(event.clientX));\n        }\n      }\n    }\n\n    arrowAdjustVolume(event) {\n      if (event.keyCode === 38 || event.keyCode === 39) {\n        event.preventDefault();\n        this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 + 10)));\n      } else if (event.keyCode === 37 || event.keyCode === 40) {\n        event.preventDefault();\n        this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 - 10)));\n      }\n    }\n\n    calculateVolume(mousePosX) {\n      const recObj = this.volumeBarRef.nativeElement.getBoundingClientRect();\n      const volumeBarOffsetLeft = recObj.left;\n      const volumeBarWidth = recObj.width;\n      return (mousePosX - volumeBarOffsetLeft) / volumeBarWidth * 100;\n    }\n\n    setVolume(vol) {\n      this.target.volume = Math.max(0, Math.min(1, vol / 100));\n      this.ariaValue = this.target.volume * 100;\n    }\n\n    getVolume() {\n      return this.target ? this.target.volume : 0;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgVolume.ɵfac = function VgVolume_Factory(t) {\n    return new (t || VgVolume)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgVolume.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgVolume,\n    selectors: [[\"vg-volume\"]],\n    viewQuery: function VgVolume_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.volumeBarRef = _t.first);\n      }\n    },\n    hostBindings: function VgVolume_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousemove\", function VgVolume_mousemove_HostBindingHandler($event) {\n          return ctx.onDrag($event);\n        }, false, i0.ɵɵresolveDocument)(\"mouseup\", function VgVolume_mouseup_HostBindingHandler($event) {\n          return ctx.onStopDrag($event);\n        }, false, i0.ɵɵresolveDocument)(\"keydown\", function VgVolume_keydown_HostBindingHandler($event) {\n          return ctx.arrowAdjustVolume($event);\n        });\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 5,\n    vars: 9,\n    consts: [[\"tabindex\", \"0\", \"role\", \"slider\", \"aria-label\", \"volume level\", \"aria-level\", \"polite\", \"aria-valuemin\", \"0\", \"aria-valuemax\", \"100\", \"aria-orientation\", \"horizontal\", 1, \"volumeBar\", 3, \"click\", \"mousedown\"], [\"volumeBar\", \"\"], [1, \"volumeBackground\", 3, \"ngClass\"], [1, \"volumeValue\"], [1, \"volumeKnob\"]],\n    template: function VgVolume_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵlistener(\"click\", function VgVolume_Template_div_click_0_listener($event) {\n          return ctx.onClick($event);\n        })(\"mousedown\", function VgVolume_Template_div_mousedown_0_listener($event) {\n          return ctx.onMouseDown($event);\n        });\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵelement(3, \"div\", 3)(4, \"div\", 4);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuenow\", ctx.ariaValue)(\"aria-valuetext\", ctx.ariaValue + \"%\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(7, _c2, ctx.isDragging));\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.getVolume() * (100 - 15) + \"%\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"left\", ctx.getVolume() * (100 - 15) + \"%\");\n      }\n    },\n    directives: [i2.NgClass],\n    styles: [\"vg-volume{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;height:50px;width:100px;cursor:pointer;color:#fff;line-height:50px}vg-volume .volumeBar{position:relative;display:flex;flex-grow:1;align-items:center}vg-volume .volumeBackground{display:flex;flex-grow:1;height:5px;pointer-events:none;background-color:#333}vg-volume .volumeValue{display:flex;height:5px;pointer-events:none;background-color:#fff;transition:all .2s ease-out}vg-volume .volumeKnob{position:absolute;width:15px;height:15px;left:0;top:50%;transform:translateY(-50%);border-radius:15px;pointer-events:none;background-color:#fff;transition:all .2s ease-out}vg-volume .volumeBackground.dragging .volumeValue,vg-volume .volumeBackground.dragging .volumeKnob{transition:none}\\n\"],\n    encapsulation: 2\n  });\n  return VgVolume;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgPlayPause = /*#__PURE__*/(() => {\n  class VgPlayPause {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.ariaValue = VgStates.VG_PAUSED;\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    onClick() {\n      this.playPause();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.playPause();\n      }\n    }\n\n    playPause() {\n      const state = this.getState();\n\n      switch (state) {\n        case VgStates.VG_PLAYING:\n          this.target.pause();\n          break;\n\n        case VgStates.VG_PAUSED:\n        case VgStates.VG_ENDED:\n          this.target.play();\n          break;\n      }\n    }\n\n    getState() {\n      this.ariaValue = this.target ? this.target.state : VgStates.VG_PAUSED;\n      return this.ariaValue;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgPlayPause.ɵfac = function VgPlayPause_Factory(t) {\n    return new (t || VgPlayPause)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgPlayPause.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgPlayPause,\n    selectors: [[\"vg-play-pause\"]],\n    hostBindings: function VgPlayPause_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function VgPlayPause_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgPlayPause_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 1,\n    vars: 6,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", 1, \"icon\"]],\n    template: function VgPlayPause_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"vg-icon-pause\", ctx.getState() === \"playing\")(\"vg-icon-play_arrow\", ctx.getState() === \"paused\" || ctx.getState() === \"ended\");\n        i0.ɵɵattribute(\"aria-label\", ctx.getState() === \"paused\" ? \"play\" : \"pause\")(\"aria-valuetext\", ctx.ariaValue);\n      }\n    },\n    styles: [\"vg-play-pause{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;height:50px;width:50px;cursor:pointer;color:#fff;line-height:50px}vg-play-pause .icon{pointer-events:none}\\n\"],\n    encapsulation: 2\n  });\n  return VgPlayPause;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgPlaybackButton = /*#__PURE__*/(() => {\n  class VgPlaybackButton {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.ariaValue = 1;\n      this.elem = ref.nativeElement;\n      this.playbackValues = ['0.5', '1.0', '1.5', '2.0'];\n      this.playbackIndex = 1;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    onClick() {\n      this.updatePlaybackSpeed();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.updatePlaybackSpeed();\n      }\n    }\n\n    updatePlaybackSpeed() {\n      this.playbackIndex = ++this.playbackIndex % this.playbackValues.length;\n\n      if (this.target instanceof VgAPI) {\n        this.target.playbackRate = this.playbackValues[this.playbackIndex];\n      } else {\n        this.target.playbackRate[this.vgFor] = this.playbackValues[this.playbackIndex];\n      }\n    }\n\n    getPlaybackRate() {\n      this.ariaValue = this.target ? this.target.playbackRate : 1.0;\n      return this.ariaValue;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgPlaybackButton.ɵfac = function VgPlaybackButton_Factory(t) {\n    return new (t || VgPlaybackButton)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgPlaybackButton.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgPlaybackButton,\n    selectors: [[\"vg-playback-button\"]],\n    hostBindings: function VgPlaybackButton_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function VgPlaybackButton_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgPlaybackButton_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\",\n      playbackValues: \"playbackValues\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", \"aria-label\", \"playback speed button\", 1, \"button\"]],\n    template: function VgPlaybackButton_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.getPlaybackRate(), \"x \");\n      }\n    },\n    styles: [\"vg-playback-button{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;height:50px;width:50px;cursor:pointer;color:#fff;line-height:50px;font-family:Helvetica Neue,Helvetica,Arial,sans-serif}vg-playback-button .button{display:flex;align-items:center;justify-content:center;width:50px}\\n\"],\n    encapsulation: 2\n  });\n  return VgPlaybackButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgScrubBar = /*#__PURE__*/(() => {\n  class VgScrubBar {\n    constructor(ref, API, vgControlsHiddenState) {\n      this.API = API;\n      this.hideScrubBar = false;\n      this.vgSlider = true;\n      this.isSeeking = false;\n      this.wasPlaying = false;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n      this.subscriptions.push(vgControlsHiddenState.isHidden.subscribe(hide => this.onHideScrubBar(hide)));\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    seekStart() {\n      if (this.target.canPlay) {\n        this.isSeeking = true;\n\n        if (this.target.state === VgStates.VG_PLAYING) {\n          this.wasPlaying = true;\n        }\n\n        this.target.pause();\n      }\n    }\n\n    seekMove(offset) {\n      if (this.isSeeking) {\n        const percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);\n        this.target.time.current = percentage * this.target.time.total / 100;\n        this.target.seekTime(percentage, true);\n      }\n    }\n\n    seekEnd(offset) {\n      this.isSeeking = false;\n\n      if (this.target.canPlay) {\n        const percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);\n        this.target.seekTime(percentage, true);\n\n        if (this.wasPlaying) {\n          this.wasPlaying = false;\n          this.target.play();\n        }\n      }\n    }\n\n    touchEnd() {\n      this.isSeeking = false;\n\n      if (this.wasPlaying) {\n        this.wasPlaying = false;\n        this.target.play();\n      }\n    }\n\n    getTouchOffset(event) {\n      let offsetLeft = 0;\n      let element = event.target;\n\n      while (element) {\n        offsetLeft += element.offsetLeft;\n        element = element.offsetParent;\n      }\n\n      return event.touches[0].pageX - offsetLeft;\n    }\n\n    onMouseDownScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive) {\n          if (!this.vgSlider) {\n            this.seekEnd($event.offsetX);\n          } else {\n            this.seekStart();\n          }\n        }\n      }\n    }\n\n    onMouseMoveScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.seekMove($event.offsetX);\n        }\n      }\n    }\n\n    onMouseUpScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.seekEnd($event.offsetX);\n        }\n      }\n    }\n\n    onTouchStartScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive) {\n          if (!this.vgSlider) {\n            this.seekEnd(this.getTouchOffset($event));\n          } else {\n            this.seekStart();\n          }\n        }\n      }\n    }\n\n    onTouchMoveScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.seekMove(this.getTouchOffset($event));\n        }\n      }\n    } // @ts-ignore\n\n\n    onTouchCancelScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.touchEnd();\n        }\n      }\n    } // @ts-ignore\n\n\n    onTouchEndScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.touchEnd();\n        }\n      }\n    }\n\n    arrowAdjustVolume(event) {\n      if (this.target) {\n        if (event.keyCode === 38 || event.keyCode === 39) {\n          event.preventDefault();\n          this.target.seekTime((this.target.time.current + 5000) / 1000, false);\n        } else if (event.keyCode === 37 || event.keyCode === 40) {\n          event.preventDefault();\n          this.target.seekTime((this.target.time.current - 5000) / 1000, false);\n        }\n      }\n    }\n\n    getPercentage() {\n      return this.target ? this.target.time.current * 100 / this.target.time.total + '%' : '0%';\n    }\n\n    onHideScrubBar(hide) {\n      this.hideScrubBar = hide;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBar.ɵfac = function VgScrubBar_Factory(t) {\n    return new (t || VgScrubBar)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI), i0.ɵɵdirectiveInject(VgControlsHidden));\n  };\n\n  VgScrubBar.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgScrubBar,\n    selectors: [[\"vg-scrub-bar\"]],\n    hostVars: 2,\n    hostBindings: function VgScrubBar_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function VgScrubBar_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDownScrubBar($event);\n        })(\"mousemove\", function VgScrubBar_mousemove_HostBindingHandler($event) {\n          return ctx.onMouseMoveScrubBar($event);\n        }, false, i0.ɵɵresolveDocument)(\"mouseup\", function VgScrubBar_mouseup_HostBindingHandler($event) {\n          return ctx.onMouseUpScrubBar($event);\n        }, false, i0.ɵɵresolveDocument)(\"touchstart\", function VgScrubBar_touchstart_HostBindingHandler($event) {\n          return ctx.onTouchStartScrubBar($event);\n        })(\"touchmove\", function VgScrubBar_touchmove_HostBindingHandler($event) {\n          return ctx.onTouchMoveScrubBar($event);\n        }, false, i0.ɵɵresolveDocument)(\"touchcancel\", function VgScrubBar_touchcancel_HostBindingHandler($event) {\n          return ctx.onTouchCancelScrubBar($event);\n        }, false, i0.ɵɵresolveDocument)(\"touchend\", function VgScrubBar_touchend_HostBindingHandler($event) {\n          return ctx.onTouchEndScrubBar($event);\n        }, false, i0.ɵɵresolveDocument)(\"keydown\", function VgScrubBar_keydown_HostBindingHandler($event) {\n          return ctx.arrowAdjustVolume($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"hide\", ctx.hideScrubBar);\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\",\n      vgSlider: \"vgSlider\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[\"tabindex\", \"0\", \"role\", \"slider\", \"aria-label\", \"scrub bar\", \"aria-level\", \"polite\", \"aria-valuemin\", \"0\", \"aria-valuemax\", \"100\", 1, \"scrubBar\"]],\n    template: function VgScrubBar_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuenow\", ctx.getPercentage())(\"aria-valuetext\", ctx.getPercentage() + \"%\");\n      }\n    },\n    styles: [\"vg-scrub-bar{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;position:absolute;width:100%;height:5px;bottom:50px;margin:0;cursor:pointer;align-items:center;background:rgba(0,0,0,.75);z-index:250;transition:bottom 1s,opacity .5s}vg-scrub-bar .scrubBar{position:relative;display:flex;flex-grow:1;align-items:center;height:100%}vg-controls vg-scrub-bar{position:relative;bottom:0;background:transparent;height:50px;flex-grow:1;flex-basis:0;margin:0 10px;transition:initial}vg-scrub-bar.hide{bottom:0;opacity:0}vg-controls vg-scrub-bar.hide{bottom:initial;opacity:initial}\\n\"],\n    encapsulation: 2\n  });\n  return VgScrubBar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgScrubBarBufferingTime = /*#__PURE__*/(() => {\n  class VgScrubBarBufferingTime {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    getBufferTime() {\n      let bufferTime = '0%';\n\n      if (this.target && this.target.buffer && this.target.buffered.length) {\n        if (this.target.time.total === 0) {\n          bufferTime = '0%';\n        } else {\n          bufferTime = this.target.buffer.end / this.target.time.total * 100 + '%';\n        }\n      }\n\n      return bufferTime;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBarBufferingTime.ɵfac = function VgScrubBarBufferingTime_Factory(t) {\n    return new (t || VgScrubBarBufferingTime)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgScrubBarBufferingTime.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgScrubBarBufferingTime,\n    selectors: [[\"vg-scrub-bar-buffering-time\"]],\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[1, \"background\"]],\n    template: function VgScrubBarBufferingTime_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.getBufferTime());\n      }\n    },\n    styles: [\"vg-scrub-bar-buffering-time{display:flex;width:100%;height:5px;pointer-events:none;position:absolute}vg-scrub-bar-buffering-time .background{background-color:#ffffff4d}vg-controls vg-scrub-bar-buffering-time{position:absolute;top:calc(50% - 3px)}vg-controls vg-scrub-bar-buffering-time .background{border-radius:2px}\\n\"],\n    encapsulation: 2\n  });\n  return VgScrubBarBufferingTime;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:no-conflicting-lifecycle\n// tslint:disable:component-class-suffix\n// tslint:disable:no-string-literal\n\n\nlet VgScrubBarCuePoints = /*#__PURE__*/(() => {\n  class VgScrubBarCuePoints {\n    constructor(ref, API) {\n      this.API = API;\n      this.onLoadedMetadataCalled = false;\n      this.cuePoints = [];\n      this.subscriptions = [];\n      this.totalCues = 0;\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      const onTimeUpdate = this.target.subscriptions.loadedMetadata;\n      this.subscriptions.push(onTimeUpdate.subscribe(this.onLoadedMetadata.bind(this)));\n\n      if (this.onLoadedMetadataCalled) {\n        this.onLoadedMetadata();\n      }\n    }\n\n    onLoadedMetadata() {\n      if (this.vgCuePoints) {\n        // We need to transform the TextTrackCueList to Array or it doesn't work on IE11/Edge.\n        // See: https://github.com/videogular/videogular2/issues/369\n        this.cuePoints = [];\n\n        for (let i = 0, l = this.vgCuePoints.length; i < l; i++) {\n          const end = this.vgCuePoints[i].endTime >= 0 ? this.vgCuePoints[i].endTime : this.vgCuePoints[i].startTime + 1;\n          const cuePointDuration = (end - this.vgCuePoints[i].startTime) * 1000;\n          let position = '0';\n          let percentWidth = '0';\n\n          if (typeof cuePointDuration === 'number' && this.target.time.total) {\n            percentWidth = cuePointDuration * 100 / this.target.time.total + '%';\n            position = this.vgCuePoints[i].startTime * 100 / Math.round(this.target.time.total / 1000) + '%';\n          }\n\n          this.vgCuePoints[i].$$style = {\n            width: percentWidth,\n            left: position\n          };\n          this.cuePoints.push(this.vgCuePoints[i]);\n        }\n      }\n    }\n\n    updateCuePoints() {\n      if (!this.target) {\n        this.onLoadedMetadataCalled = true;\n        return;\n      }\n\n      this.onLoadedMetadata();\n    }\n\n    ngOnChanges(changes) {\n      if (changes['vgCuePoints'].currentValue) {\n        this.updateCuePoints();\n      }\n    }\n\n    ngDoCheck() {\n      if (this.vgCuePoints) {\n        const changes = this.totalCues !== this.vgCuePoints.length;\n\n        if (changes) {\n          this.totalCues = this.vgCuePoints.length;\n          this.updateCuePoints();\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBarCuePoints.ɵfac = function VgScrubBarCuePoints_Factory(t) {\n    return new (t || VgScrubBarCuePoints)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgScrubBarCuePoints.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgScrubBarCuePoints,\n    selectors: [[\"vg-scrub-bar-cue-points\"]],\n    inputs: {\n      vgCuePoints: \"vgCuePoints\",\n      vgFor: \"vgFor\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"cue-point-container\"], [\"class\", \"cue-point\", 3, \"width\", \"left\", 4, \"ngFor\", \"ngForOf\"], [1, \"cue-point\"]],\n    template: function VgScrubBarCuePoints_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, VgScrubBarCuePoints_span_1_Template, 1, 4, \"span\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.cuePoints);\n      }\n    },\n    directives: [i2.NgForOf],\n    styles: [\"vg-scrub-bar-cue-points{display:flex;width:100%;height:5px;pointer-events:none;position:absolute}vg-scrub-bar-cue-points .cue-point-container .cue-point{position:absolute;height:5px;background-color:#ffcc00b3}vg-controls vg-scrub-bar-cue-points{position:absolute;top:calc(50% - 3px)}\\n\"],\n    encapsulation: 2\n  });\n  return VgScrubBarCuePoints;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgScrubBarCurrentTime = /*#__PURE__*/(() => {\n  class VgScrubBarCurrentTime {\n    constructor(ref, API) {\n      this.API = API;\n      this.vgSlider = false;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    getPercentage() {\n      return this.target ? this.target.time.current * 100 / this.target.time.total + '%' : '0%';\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBarCurrentTime.ɵfac = function VgScrubBarCurrentTime_Factory(t) {\n    return new (t || VgScrubBarCurrentTime)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgScrubBarCurrentTime.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgScrubBarCurrentTime,\n    selectors: [[\"vg-scrub-bar-current-time\"]],\n    inputs: {\n      vgFor: \"vgFor\",\n      vgSlider: \"vgSlider\"\n    },\n    decls: 2,\n    vars: 3,\n    consts: [[1, \"background\"], [\"class\", \"slider\", 4, \"ngIf\"], [1, \"slider\"]],\n    template: function VgScrubBarCurrentTime_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n        i0.ɵɵtemplate(1, VgScrubBarCurrentTime_span_1_Template, 1, 0, \"span\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.getPercentage());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.vgSlider);\n      }\n    },\n    directives: [i2.NgIf],\n    styles: [\"vg-scrub-bar-current-time{display:flex;width:100%;height:5px;pointer-events:none;position:absolute}vg-scrub-bar-current-time .background{background-color:#fff}vg-controls vg-scrub-bar-current-time{position:absolute;top:calc(50% - 3px);border-radius:2px}vg-controls vg-scrub-bar-current-time .background{border:1px solid white;border-radius:2px}vg-scrub-bar-current-time .slider{background:white;height:15px;width:15px;border-radius:50%;box-shadow:0 0 10px #000;margin-top:-5px;margin-left:-10px}\\n\"],\n    encapsulation: 2\n  });\n  return VgScrubBarCurrentTime;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Workaround until we can use UTC with Angular Date Pipe\n\n\nlet VgUtcPipe = /*#__PURE__*/(() => {\n  class VgUtcPipe {\n    transform(value, format) {\n      const date = new Date(value);\n      let result = format;\n      let ss = date.getUTCSeconds();\n      let mm = date.getUTCMinutes();\n      let hh = date.getUTCHours();\n\n      if (ss < 10) {\n        ss = '0' + ss;\n      }\n\n      if (mm < 10) {\n        mm = '0' + mm;\n      }\n\n      if (hh < 10) {\n        hh = '0' + hh;\n      }\n\n      result = result.replace(/ss/g, ss);\n      result = result.replace(/mm/g, mm);\n      result = result.replace(/hh/g, hh);\n      return result;\n    }\n\n  }\n\n  VgUtcPipe.ɵfac = function VgUtcPipe_Factory(t) {\n    return new (t || VgUtcPipe)();\n  };\n\n  VgUtcPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"vgUtc\",\n    type: VgUtcPipe,\n    pure: true\n  });\n  return VgUtcPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgTimeDisplay = /*#__PURE__*/(() => {\n  class VgTimeDisplay {\n    constructor(ref, API) {\n      this.API = API;\n      this.vgProperty = 'current';\n      this.vgFormat = 'mm:ss';\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    getTime() {\n      let t = 0;\n\n      if (this.target) {\n        t = Math.round(this.target.time[this.vgProperty]);\n        t = isNaN(t) || this.target.isLive ? 0 : t;\n      }\n\n      return t;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgTimeDisplay.ɵfac = function VgTimeDisplay_Factory(t) {\n    return new (t || VgTimeDisplay)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgTimeDisplay.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgTimeDisplay,\n    selectors: [[\"vg-time-display\"]],\n    inputs: {\n      vgFor: \"vgFor\",\n      vgProperty: \"vgProperty\",\n      vgFormat: \"vgFormat\"\n    },\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\"]],\n    template: function VgTimeDisplay_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, VgTimeDisplay_span_0_Template, 2, 0, \"span\", 0);\n        i0.ɵɵtemplate(1, VgTimeDisplay_span_1_Template, 3, 4, \"span\", 0);\n        i0.ɵɵprojection(2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.target == null ? null : ctx.target.isLive);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !(ctx.target == null ? null : ctx.target.isLive));\n      }\n    },\n    directives: [i2.NgIf],\n    pipes: [VgUtcPipe],\n    styles: [\"vg-time-display{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;height:50px;width:60px;cursor:pointer;color:#fff;line-height:50px;pointer-events:none;font-family:Helvetica Neue,Helvetica,Arial,sans-serif}\\n\"],\n    encapsulation: 2\n  });\n  return VgTimeDisplay;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n\n\nlet VgTrackSelector = /*#__PURE__*/(() => {\n  class VgTrackSelector {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      const subs = Array.from(this.API.getMasterMedia().elem.children).filter(item => item.tagName === 'TRACK').filter(item => item.kind === 'subtitles').map(item => ({\n        label: item.label,\n        selected: item.default === true,\n        id: item.srclang\n      }));\n      this.tracks = [...subs, {\n        id: null,\n        label: 'Off',\n        selected: subs.every(item => item.selected === false)\n      }];\n      const track = this.tracks.filter(item => item.selected === true)[0];\n      this.trackSelected = track.id;\n      this.ariaValue = track.label;\n    }\n\n    selectTrack(trackId) {\n      this.trackSelected = trackId === 'null' ? null : trackId;\n      this.ariaValue = 'No track selected';\n      Array.from(this.API.getMasterMedia().elem.textTracks).forEach(item => {\n        if (item.language === trackId) {\n          this.ariaValue = item.label;\n          item.mode = 'showing';\n        } else {\n          item.mode = 'hidden';\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgTrackSelector.ɵfac = function VgTrackSelector_Factory(t) {\n    return new (t || VgTrackSelector)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgTrackSelector.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgTrackSelector,\n    selectors: [[\"vg-track-selector\"]],\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 5,\n    vars: 5,\n    consts: [[1, \"container\"], [1, \"track-selected\"], [\"tabindex\", \"0\", \"aria-label\", \"track selector\", 1, \"trackSelector\", 3, \"change\"], [3, \"value\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\", \"selected\"]],\n    template: function VgTrackSelector_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"select\", 2);\n        i0.ɵɵlistener(\"change\", function VgTrackSelector_Template_select_change_3_listener($event) {\n          return ctx.selectTrack($event.target.value);\n        });\n        i0.ɵɵtemplate(4, VgTrackSelector_option_4_Template, 2, 3, \"option\", 3);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"vg-icon-closed_caption\", !ctx.trackSelected);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.trackSelected || \"\", \" \");\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.tracks);\n      }\n    },\n    directives: [i2.NgForOf],\n    styles: [\"vg-track-selector{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;width:50px;height:50px;cursor:pointer;color:#fff;line-height:50px}vg-track-selector .container{position:relative;display:flex;flex-grow:1;align-items:center;padding:0;margin:5px}vg-track-selector select.trackSelector{width:50px;padding:5px 8px;border:none;background:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;color:transparent;font-size:16px}vg-track-selector select.trackSelector::-ms-expand{display:none}vg-track-selector select.trackSelector option{color:#000}vg-track-selector .track-selected{position:absolute;width:100%;height:50px;top:-6px;text-align:center;text-transform:uppercase;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;padding-top:2px;pointer-events:none}vg-track-selector .vg-icon-closed_caption:before{width:100%}\\n\"],\n    encapsulation: 2\n  });\n  return VgTrackSelector;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:no-output-on-prefix\n// tslint:disable:component-class-suffix\n// tslint:disable:no-string-literal\n\n\nlet VgQualitySelector = /*#__PURE__*/(() => {\n  class VgQualitySelector {\n    constructor(ref, API) {\n      this.API = API;\n      this.onBitrateChange = new EventEmitter();\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {}\n\n    ngOnChanges(changes) {\n      if (changes['bitrates'].currentValue && changes['bitrates'].currentValue.length) {\n        this.bitrates.forEach(item => item.label = (item.label || Math.round(item.bitrate / 1000)).toString());\n      }\n    }\n\n    selectBitrate(index) {\n      this.bitrateSelected = this.bitrates[index];\n      this.onBitrateChange.emit(this.bitrates[index]);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgQualitySelector.ɵfac = function VgQualitySelector_Factory(t) {\n    return new (t || VgQualitySelector)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgQualitySelector.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgQualitySelector,\n    selectors: [[\"vg-quality-selector\"]],\n    inputs: {\n      bitrates: \"bitrates\"\n    },\n    outputs: {\n      onBitrateChange: \"onBitrateChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 5,\n    consts: [[1, \"container\"], [1, \"quality-selected\"], [\"tabindex\", \"0\", \"aria-label\", \"quality selector\", 1, \"quality-selector\", 3, \"change\"], [3, \"value\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\", \"selected\"]],\n    template: function VgQualitySelector_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"select\", 2);\n        i0.ɵɵlistener(\"change\", function VgQualitySelector_Template_select_change_3_listener($event) {\n          return ctx.selectBitrate($event.target.value);\n        });\n        i0.ɵɵtemplate(4, VgQualitySelector_option_4_Template, 2, 3, \"option\", 3);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"vg-icon-hd\", !ctx.bitrateSelected);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.bitrateSelected == null ? null : ctx.bitrateSelected.label, \" \");\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.bitrates);\n      }\n    },\n    directives: [i2.NgForOf],\n    styles: [\"vg-quality-selector{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;width:50px;height:50px;cursor:pointer;color:#fff;line-height:50px}vg-quality-selector .container{position:relative;display:flex;flex-grow:1;align-items:center;padding:0;margin:5px}vg-quality-selector select.quality-selector{width:50px;padding:5px 8px;border:none;background:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;color:transparent;font-size:16px}vg-quality-selector select.quality-selector::-ms-expand{display:none}vg-quality-selector select.quality-selector option{color:#000}vg-quality-selector .quality-selected{position:absolute;width:100%;height:50px;top:-6px;text-align:center;text-transform:uppercase;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;padding-top:2px;pointer-events:none}vg-quality-selector .vg-icon-closed_caption:before{width:100%}\\n\"],\n    encapsulation: 2\n  });\n  return VgQualitySelector;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgControlsModule = /*#__PURE__*/(() => {\n  class VgControlsModule {}\n\n  VgControlsModule.ɵfac = function VgControlsModule_Factory(t) {\n    return new (t || VgControlsModule)();\n  };\n\n  VgControlsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: VgControlsModule\n  });\n  VgControlsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [VgControlsHidden],\n    imports: [[CommonModule]]\n  });\n  return VgControlsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgEvents = /*#__PURE__*/(() => {\n  class VgEvents {}\n\n  VgEvents.VG_ABORT = 'abort';\n  VgEvents.VG_CAN_PLAY = 'canplay';\n  VgEvents.VG_CAN_PLAY_THROUGH = 'canplaythrough';\n  VgEvents.VG_DURATION_CHANGE = 'durationchange';\n  VgEvents.VG_EMPTIED = 'emptied';\n  VgEvents.VG_ENCRYPTED = 'encrypted';\n  VgEvents.VG_ENDED = 'ended';\n  VgEvents.VG_ERROR = 'error';\n  VgEvents.VG_LOADED_DATA = 'loadeddata';\n  VgEvents.VG_LOADED_METADATA = 'loadedmetadata';\n  VgEvents.VG_LOAD_START = 'loadstart';\n  VgEvents.VG_PAUSE = 'pause';\n  VgEvents.VG_PLAY = 'play';\n  VgEvents.VG_PLAYING = 'playing';\n  VgEvents.VG_PROGRESS = 'progress';\n  VgEvents.VG_RATE_CHANGE = 'ratechange';\n  VgEvents.VG_SEEK = 'seek';\n  VgEvents.VG_SEEKED = 'seeked';\n  VgEvents.VG_SEEKING = 'seeking';\n  VgEvents.VG_STALLED = 'stalled';\n  VgEvents.VG_SUSPEND = 'suspend';\n  VgEvents.VG_TIME_UPDATE = 'timeupdate';\n  VgEvents.VG_VOLUME_CHANGE = 'volumechange';\n  VgEvents.VG_WAITING = 'waiting';\n  VgEvents.VG_LOAD = 'load';\n  VgEvents.VG_ENTER = 'enter';\n  VgEvents.VG_EXIT = 'exit';\n  VgEvents.VG_START_ADS = 'startads';\n  VgEvents.VG_END_ADS = 'endads';\n\n  VgEvents.ɵfac = function VgEvents_Factory(t) {\n    return new (t || VgEvents)();\n  };\n\n  VgEvents.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: VgEvents,\n    factory: VgEvents.ɵfac\n  });\n  return VgEvents;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line:directive-class-suffix\n\n\nlet VgMedia = /*#__PURE__*/(() => {\n  class VgMedia {\n    constructor(api, ref) {\n      this.api = api;\n      this.ref = ref;\n      this.state = VgStates.VG_PAUSED;\n      this.time = {\n        current: 0,\n        total: 0,\n        left: 0\n      };\n      this.buffer = {\n        end: 0\n      };\n      this.canPlay = false;\n      this.canPlayThrough = false;\n      this.isMetadataLoaded = false;\n      this.isWaiting = false;\n      this.isCompleted = false;\n      this.isLive = false;\n      this.isBufferDetected = false;\n      this.checkInterval = 200;\n      this.currentPlayPos = 0;\n      this.lastPlayPos = 0;\n      this.playAtferSync = false;\n      this.bufferDetected = new Subject();\n    }\n\n    ngOnInit() {\n      if (this.vgMedia.nodeName) {\n        // It's a native element\n        this.elem = this.vgMedia;\n      } else {\n        // It's an Angular Class\n        this.elem = this.vgMedia.elem;\n      } // Just in case we're creating this vgMedia dynamically register again into API\n\n\n      this.api.registerMedia(this);\n      this.subscriptions = {\n        // Native events\n        abort: fromEvent(this.elem, VgEvents.VG_ABORT),\n        canPlay: fromEvent(this.elem, VgEvents.VG_CAN_PLAY),\n        canPlayThrough: fromEvent(this.elem, VgEvents.VG_CAN_PLAY_THROUGH),\n        durationChange: fromEvent(this.elem, VgEvents.VG_DURATION_CHANGE),\n        emptied: fromEvent(this.elem, VgEvents.VG_EMPTIED),\n        encrypted: fromEvent(this.elem, VgEvents.VG_ENCRYPTED),\n        ended: fromEvent(this.elem, VgEvents.VG_ENDED),\n        error: fromEvent(this.elem, VgEvents.VG_ERROR),\n        loadedData: fromEvent(this.elem, VgEvents.VG_LOADED_DATA),\n        loadedMetadata: fromEvent(this.elem, VgEvents.VG_LOADED_METADATA),\n        loadStart: fromEvent(this.elem, VgEvents.VG_LOAD_START),\n        pause: fromEvent(this.elem, VgEvents.VG_PAUSE),\n        play: fromEvent(this.elem, VgEvents.VG_PLAY),\n        playing: fromEvent(this.elem, VgEvents.VG_PLAYING),\n        progress: fromEvent(this.elem, VgEvents.VG_PROGRESS),\n        rateChange: fromEvent(this.elem, VgEvents.VG_RATE_CHANGE),\n        seeked: fromEvent(this.elem, VgEvents.VG_SEEKED),\n        seeking: fromEvent(this.elem, VgEvents.VG_SEEKING),\n        stalled: fromEvent(this.elem, VgEvents.VG_STALLED),\n        suspend: fromEvent(this.elem, VgEvents.VG_SUSPEND),\n        timeUpdate: fromEvent(this.elem, VgEvents.VG_TIME_UPDATE),\n        volumeChange: fromEvent(this.elem, VgEvents.VG_VOLUME_CHANGE),\n        waiting: fromEvent(this.elem, VgEvents.VG_WAITING),\n        // Advertisement only events\n        startAds: fromEvent(this.elem, VgEvents.VG_START_ADS),\n        endAds: fromEvent(this.elem, VgEvents.VG_END_ADS),\n        // See changes on <source> child elements to reload the video file\n        mutation: new Observable(observer => {\n          const domObs = new MutationObserver(mutations => {\n            observer.next(mutations);\n          });\n          domObs.observe(this.elem, {\n            childList: true,\n            attributes: true\n          });\n          return () => {\n            domObs.disconnect();\n          };\n        }),\n        // Custom buffering detection\n        bufferDetected: this.bufferDetected\n      };\n      this.mutationObs = this.subscriptions.mutation.subscribe(this.onMutation.bind(this));\n      this.canPlayObs = this.subscriptions.canPlay.subscribe(this.onCanPlay.bind(this));\n      this.canPlayThroughObs = this.subscriptions.canPlayThrough.subscribe(this.onCanPlayThrough.bind(this));\n      this.loadedMetadataObs = this.subscriptions.loadedMetadata.subscribe(this.onLoadMetadata.bind(this));\n      this.waitingObs = this.subscriptions.waiting.subscribe(this.onWait.bind(this));\n      this.progressObs = this.subscriptions.progress.subscribe(this.onProgress.bind(this));\n      this.endedObs = this.subscriptions.ended.subscribe(this.onComplete.bind(this));\n      this.playingObs = this.subscriptions.playing.subscribe(this.onStartPlaying.bind(this));\n      this.playObs = this.subscriptions.play.subscribe(this.onPlay.bind(this));\n      this.pauseObs = this.subscriptions.pause.subscribe(this.onPause.bind(this));\n      this.timeUpdateObs = this.subscriptions.timeUpdate.subscribe(this.onTimeUpdate.bind(this));\n      this.volumeChangeObs = this.subscriptions.volumeChange.subscribe(this.onVolumeChange.bind(this));\n      this.errorObs = this.subscriptions.error.subscribe(this.onError.bind(this));\n\n      if (this.vgMaster) {\n        this.api.playerReadyEvent.subscribe(() => {\n          this.prepareSync();\n        });\n      }\n    }\n\n    prepareSync() {\n      const canPlayAll = [];\n\n      for (const media in this.api.medias) {\n        if (this.api.medias[media]) {\n          canPlayAll.push(this.api.medias[media].subscriptions.canPlay);\n        }\n      }\n\n      this.canPlayAllSubscription = combineLatest(canPlayAll).pipe(map((...params) => {\n        const checkReadyState = event => {\n          return event.target.readyState === 4;\n        };\n\n        const allReady = params.some(checkReadyState);\n\n        if (allReady && !this.syncSubscription) {\n          this.startSync();\n          this.syncSubscription.unsubscribe();\n        }\n      })).subscribe();\n    }\n\n    startSync() {\n      this.syncSubscription = timer(0, 1000).subscribe(() => {\n        for (const media in this.api.medias) {\n          if (this.api.medias[media] !== this) {\n            const diff = this.api.medias[media].currentTime - this.currentTime;\n\n            if (diff < -0.3 || diff > 0.3) {\n              this.playAtferSync = this.state === VgStates.VG_PLAYING;\n              this.pause();\n              this.api.medias[media].pause();\n              this.api.medias[media].currentTime = this.currentTime;\n            } else {\n              if (this.playAtferSync) {\n                this.play();\n                this.api.medias[media].play();\n                this.playAtferSync = false;\n              }\n            }\n          }\n        }\n      });\n    }\n\n    onMutation(mutations) {\n      // Detect changes only for source elements or src attribute\n      for (let i = 0, l = mutations.length; i < l; i++) {\n        const mut = mutations[i];\n\n        if (mut.type === 'attributes' && mut.attributeName === 'src') {\n          // Only load src file if it's not a blob (for DASH / HLS sources)\n          // tslint:disable-next-line:no-string-literal\n          if (mut.target['src'] && mut.target['src'].length > 0 && mut.target['src'].indexOf('blob:') < 0) {\n            this.loadMedia();\n            break;\n          }\n        } else if (mut.type === 'childList' && mut.removedNodes.length && mut.removedNodes[0].nodeName.toLowerCase() === 'source') {\n          this.loadMedia();\n          break;\n        }\n      }\n    }\n\n    loadMedia() {\n      this.vgMedia.pause();\n      this.vgMedia.currentTime = 0; // Start buffering until we can play the media file\n\n      this.stopBufferCheck();\n      this.isBufferDetected = true;\n      this.bufferDetected.next(this.isBufferDetected); // TODO: This is ugly, we should find something cleaner. For some reason a TimerObservable doesn't works.\n\n      setTimeout(() => this.vgMedia.load(), 10);\n    }\n\n    play() {\n      // short-circuit if already playing\n      if (this.playPromise || this.state !== VgStates.VG_PAUSED && this.state !== VgStates.VG_ENDED) {\n        return;\n      }\n\n      this.playPromise = this.vgMedia.play(); // browser has async play promise\n\n      if (this.playPromise && this.playPromise.then && this.playPromise.catch) {\n        this.playPromise.then(() => {\n          this.playPromise = null;\n        }).catch(() => {\n          this.playPromise = null; // deliberately empty for the sake of eating console noise\n        });\n      }\n\n      return this.playPromise;\n    }\n\n    pause() {\n      // browser has async play promise\n      if (this.playPromise) {\n        this.playPromise.then(() => {\n          this.vgMedia.pause();\n        });\n      } else {\n        this.vgMedia.pause();\n      }\n    }\n\n    get id() {\n      // We should return undefined if vgMedia still doesn't exist\n      // tslint:disable-next-line:no-unnecessary-initializer\n      let result = undefined;\n\n      if (this.vgMedia) {\n        result = this.vgMedia.id;\n      }\n\n      return result;\n    }\n\n    get duration() {\n      return this.vgMedia.duration;\n    }\n\n    set currentTime(seconds) {\n      this.vgMedia.currentTime = seconds; // this.elem.dispatchEvent(new CustomEvent(VgEvents.VG_SEEK));\n    }\n\n    get currentTime() {\n      return this.vgMedia.currentTime;\n    }\n\n    set volume(volume) {\n      this.vgMedia.volume = volume;\n    }\n\n    get volume() {\n      return this.vgMedia.volume;\n    }\n\n    set playbackRate(rate) {\n      this.vgMedia.playbackRate = rate;\n    }\n\n    get playbackRate() {\n      return this.vgMedia.playbackRate;\n    }\n\n    get buffered() {\n      return this.vgMedia.buffered;\n    }\n\n    get textTracks() {\n      return this.vgMedia.textTracks;\n    } // @ts-ignore\n\n\n    onCanPlay(event) {\n      this.isBufferDetected = false;\n      this.bufferDetected.next(this.isBufferDetected);\n      this.canPlay = true;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onCanPlayThrough(event) {\n      this.isBufferDetected = false;\n      this.bufferDetected.next(this.isBufferDetected);\n      this.canPlayThrough = true;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onLoadMetadata(event) {\n      this.isMetadataLoaded = true;\n      this.time = {\n        current: 0,\n        left: 0,\n        total: this.duration * 1000\n      };\n      this.state = VgStates.VG_PAUSED; // Live streaming check\n\n      const t = Math.round(this.time.total);\n      this.isLive = t === Infinity;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onWait(event) {\n      this.isWaiting = true;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onComplete(event) {\n      this.isCompleted = true;\n      this.state = VgStates.VG_ENDED;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onStartPlaying(event) {\n      this.state = VgStates.VG_PLAYING;\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onPlay(event) {\n      this.state = VgStates.VG_PLAYING;\n\n      if (this.vgMaster) {\n        if (!this.syncSubscription || this.syncSubscription.closed) {\n          this.startSync();\n        }\n      }\n\n      this.startBufferCheck();\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onPause(event) {\n      this.state = VgStates.VG_PAUSED;\n\n      if (this.vgMaster) {\n        if (!this.playAtferSync) {\n          this.syncSubscription.unsubscribe();\n        }\n      }\n\n      this.stopBufferCheck();\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onTimeUpdate(event) {\n      var _a;\n\n      const end = ((_a = this.buffered) === null || _a === void 0 ? void 0 : _a.length) - 1;\n      this.time = {\n        current: this.currentTime * 1000,\n        total: this.time.total,\n        left: (this.duration - this.currentTime) * 1000\n      };\n\n      if (end >= 0) {\n        this.buffer = {\n          end: this.buffered.end(end) * 1000\n        };\n      }\n\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onProgress(event) {\n      const end = this.buffered.length - 1;\n\n      if (end >= 0) {\n        this.buffer = {\n          end: this.buffered.end(end) * 1000\n        };\n      }\n\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onVolumeChange(event) {\n      // TODO: Save to localstorage the current volume\n      this.ref.detectChanges();\n    } // @ts-ignore\n\n\n    onError(event) {\n      // TODO: Handle error messages\n      this.ref.detectChanges();\n    } // http://stackoverflow.com/a/23828241/779529\n\n\n    bufferCheck() {\n      const offset = 1 / this.checkInterval;\n      this.currentPlayPos = this.currentTime;\n\n      if (!this.isBufferDetected && this.currentPlayPos < this.lastPlayPos + offset) {\n        this.isBufferDetected = true;\n      }\n\n      if (this.isBufferDetected && this.currentPlayPos > this.lastPlayPos + offset) {\n        this.isBufferDetected = false;\n      } // Prevent calls to bufferCheck after ngOnDestroy have been called\n\n\n      if (!this.bufferDetected.closed) {\n        this.bufferDetected.next(this.isBufferDetected);\n      }\n\n      this.lastPlayPos = this.currentPlayPos;\n    }\n\n    startBufferCheck() {\n      this.checkBufferSubscription = timer(0, this.checkInterval).subscribe(() => {\n        this.bufferCheck();\n      });\n    }\n\n    stopBufferCheck() {\n      if (this.checkBufferSubscription) {\n        this.checkBufferSubscription.unsubscribe();\n      }\n\n      this.isBufferDetected = false;\n      this.bufferDetected.next(this.isBufferDetected);\n    }\n\n    seekTime(value, byPercent = false) {\n      let second;\n      const duration = this.duration;\n\n      if (byPercent) {\n        second = value * duration / 100;\n      } else {\n        second = value;\n      }\n\n      this.currentTime = second;\n    }\n\n    addTextTrack(type, label, language, mode) {\n      const newTrack = this.vgMedia.addTextTrack(type, label, language);\n\n      if (mode) {\n        newTrack.mode = mode;\n      }\n\n      return newTrack;\n    }\n\n    ngOnDestroy() {\n      this.vgMedia.src = '';\n      this.mutationObs.unsubscribe();\n      this.canPlayObs.unsubscribe();\n      this.canPlayThroughObs.unsubscribe();\n      this.loadedMetadataObs.unsubscribe();\n      this.waitingObs.unsubscribe();\n      this.progressObs.unsubscribe();\n      this.endedObs.unsubscribe();\n      this.playingObs.unsubscribe();\n      this.playObs.unsubscribe();\n      this.pauseObs.unsubscribe();\n      this.timeUpdateObs.unsubscribe();\n      this.volumeChangeObs.unsubscribe();\n      this.errorObs.unsubscribe();\n\n      if (this.checkBufferSubscription) {\n        this.checkBufferSubscription.unsubscribe();\n      }\n\n      if (this.syncSubscription) {\n        this.syncSubscription.unsubscribe();\n      }\n\n      this.bufferDetected.complete();\n      this.bufferDetected.unsubscribe();\n      this.api.unregisterMedia(this);\n    }\n\n  }\n\n  VgMedia.ɵfac = function VgMedia_Factory(t) {\n    return new (t || VgMedia)(i0.ɵɵdirectiveInject(VgAPI), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  VgMedia.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VgMedia,\n    selectors: [[\"\", \"vgMedia\", \"\"]],\n    inputs: {\n      vgMedia: \"vgMedia\",\n      vgMaster: \"vgMaster\"\n    }\n  });\n  return VgMedia;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line:directive-class-suffix\n\n\nlet VgCuePoints = /*#__PURE__*/(() => {\n  class VgCuePoints {\n    constructor(ref) {\n      this.ref = ref; // tslint:disable:no-output-on-prefix\n\n      this.onEnterCuePoint = new EventEmitter();\n      this.onUpdateCuePoint = new EventEmitter();\n      this.onExitCuePoint = new EventEmitter();\n      this.onCompleteCuePoint = new EventEmitter();\n      this.subscriptions = [];\n      this.cuesSubscriptions = [];\n      this.totalCues = 0;\n    }\n\n    ngOnInit() {\n      this.onLoad$ = fromEvent(this.ref.nativeElement, VgEvents.VG_LOAD);\n      this.subscriptions.push(this.onLoad$.subscribe(this.onLoad.bind(this)));\n    }\n\n    onLoad(event) {\n      if (event.target && event.target.track) {\n        const cues = event.target.track.cues;\n        this.ref.nativeElement.cues = cues;\n        this.updateCuePoints(cues);\n      } else if (event.target && event.target.textTracks && event.target.textTracks.length) {\n        const cues = event.target.textTracks[0].cues;\n        this.ref.nativeElement.cues = cues;\n        this.updateCuePoints(cues);\n      }\n    }\n\n    updateCuePoints(cues) {\n      this.cuesSubscriptions.forEach(s => s.unsubscribe());\n\n      for (let i = 0, l = cues.length; i < l; i++) {\n        this.onEnter$ = fromEvent(cues[i], VgEvents.VG_ENTER);\n        this.cuesSubscriptions.push(this.onEnter$.subscribe(this.onEnter.bind(this)));\n        this.onExit$ = fromEvent(cues[i], VgEvents.VG_EXIT);\n        this.cuesSubscriptions.push(this.onExit$.subscribe(this.onExit.bind(this)));\n      }\n    }\n\n    onEnter(event) {\n      this.onEnterCuePoint.emit(event.target);\n    }\n\n    onExit(event) {\n      this.onExitCuePoint.emit(event.target);\n    }\n\n    ngDoCheck() {\n      if (this.ref.nativeElement.track && this.ref.nativeElement.track.cues) {\n        const changes = this.totalCues !== this.ref.nativeElement.track.cues.length;\n\n        if (changes) {\n          this.totalCues = this.ref.nativeElement.track.cues.length;\n          this.ref.nativeElement.cues = this.ref.nativeElement.track.cues;\n          this.updateCuePoints(this.ref.nativeElement.track.cues);\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgCuePoints.ɵfac = function VgCuePoints_Factory(t) {\n    return new (t || VgCuePoints)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  VgCuePoints.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VgCuePoints,\n    selectors: [[\"\", \"vgCuePoints\", \"\"]],\n    outputs: {\n      onEnterCuePoint: \"onEnterCuePoint\",\n      onUpdateCuePoint: \"onUpdateCuePoint\",\n      onExitCuePoint: \"onExitCuePoint\",\n      onCompleteCuePoint: \"onCompleteCuePoint\"\n    }\n  });\n  return VgCuePoints;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:component-class-suffix\n// tslint:disable:no-output-on-prefix\n\n\nlet VgPlayer = /*#__PURE__*/(() => {\n  class VgPlayer {\n    constructor(ref, api, fsAPI, controlsHidden) {\n      this.api = api;\n      this.fsAPI = fsAPI;\n      this.controlsHidden = controlsHidden;\n      this.isFullscreen = false;\n      this.isNativeFullscreen = false;\n      this.areControlsHidden = false;\n      this.onPlayerReady = new EventEmitter();\n      this.onMediaReady = new EventEmitter();\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n      this.api.registerElement(this.elem);\n    }\n\n    ngAfterContentInit() {\n      this.medias.toArray().forEach(media => {\n        this.api.registerMedia(media);\n      });\n      this.fsAPI.init(this.elem, this.medias);\n      this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n      this.subscriptions.push(this.controlsHidden.isHidden.subscribe(this.onHideControls.bind(this)));\n      this.api.onPlayerReady(this.fsAPI);\n      this.onPlayerReady.emit(this.api);\n    }\n\n    onChangeFullscreen(fsState) {\n      if (!this.fsAPI.nativeFullscreen) {\n        this.isFullscreen = fsState;\n        this.zIndex = fsState ? VgUtils.getZIndex().toString() : 'auto';\n      } else {\n        this.isNativeFullscreen = fsState;\n      }\n    }\n\n    onHideControls(hidden) {\n      this.areControlsHidden = hidden;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgPlayer.ɵfac = function VgPlayer_Factory(t) {\n    return new (t || VgPlayer)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI), i0.ɵɵdirectiveInject(VgFullscreenAPI), i0.ɵɵdirectiveInject(VgControlsHidden));\n  };\n\n  VgPlayer.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgPlayer,\n    selectors: [[\"vg-player\"]],\n    contentQueries: function VgPlayer_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, VgMedia, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.medias = _t);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function VgPlayer_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"z-index\", ctx.zIndex);\n        i0.ɵɵclassProp(\"fullscreen\", ctx.isFullscreen)(\"native-fullscreen\", ctx.isNativeFullscreen)(\"controls-hidden\", ctx.areControlsHidden);\n      }\n    },\n    outputs: {\n      onPlayerReady: \"onPlayerReady\",\n      onMediaReady: \"onMediaReady\"\n    },\n    features: [i0.ɵɵProvidersFeature([VgAPI, VgFullscreenAPI, VgControlsHidden])],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function VgPlayer_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"vg-player{font-family:videogular;position:relative;display:flex;width:100%;height:100%;overflow:hidden;background-color:#000}vg-player.fullscreen{position:fixed;left:0;top:0}vg-player.native-fullscreen.controls-hidden{cursor:none}\\n\"],\n    encapsulation: 2\n  });\n  return VgPlayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass VgMediaElement {\n  get audioTracks() {\n    return null;\n  } // @ts-ignore\n\n\n  addTextTrack(kind, label, language) {\n    return null;\n  } // @ts-ignore\n\n\n  canPlayType(type) {\n    return null;\n  }\n\n  load() {}\n\n  msClearEffects() {}\n\n  msGetAsCastingSource() {\n    return null;\n  } // @ts-ignore\n\n\n  msInsertAudioEffect(activatableClassId, effectRequired, config) {} // @ts-ignore\n\n\n  msSetMediaKeys(mediaKeys) {} // @ts-ignore\n\n\n  msSetMediaProtectionManager(mediaProtectionManager) {}\n\n  pause() {}\n\n  play() {\n    return null;\n  } // @ts-ignore\n\n\n  setMediaKeys(mediaKeys) {\n    return null;\n  } // @ts-ignore\n\n\n  addEventListener(type, listener, useCapture) {}\n\n} ///<reference path='./google.ima.ts'/>\n// tslint:disable:no-output-on-prefix\n// tslint:disable:ban-types\n// tslint:disable:component-class-suffix\n\n\nlet VgImaAds = /*#__PURE__*/(() => {\n  class VgImaAds {\n    constructor(ref, API, fsAPI) {\n      this.API = API;\n      this.fsAPI = fsAPI;\n      this.onAdStart = new EventEmitter();\n      this.onAdStop = new EventEmitter();\n      this.onSkipAd = new EventEmitter();\n      this.isFullscreen = false;\n      this.subscriptions = [];\n      this.displayState = 'none';\n      this.elem = ref.nativeElement;\n      this.onContentEnded = this.onContentEnded.bind(this);\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      if (typeof google === 'undefined') {\n        this.onMissingGoogleImaLoader();\n        return;\n      }\n\n      this.target = this.API.getMediaById(this.vgFor);\n      this.initializations();\n      this.subscriptions.push(this.target.subscriptions.ended.subscribe(this.onContentEnded.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.play.subscribe(this.onUpdateState.bind(this)));\n      this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n      this.ima.adsLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdsManagerLoaded.bind(this), false);\n      this.ima.adsLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError.bind(this), false);\n      this.loadAds();\n    }\n\n    initializations() {\n      this.ima = new Ima(this.elem);\n\n      if (this.vgSkipButton) {\n        this.skipButton = document.querySelector(this.vgSkipButton);\n        this.skipButton.style.display = 'none';\n        this.skipButton.addEventListener('click', this.onClickSkip.bind(this));\n        this.elem.insertBefore(this.skipButton, this.elem.firstChild);\n      }\n\n      window.addEventListener('resize', () => {\n        const w = this.API.videogularElement.offsetWidth;\n        const h = this.API.videogularElement.offsetHeight;\n\n        if (this.ima.adsManager) {\n          if (this.isFullscreen) {\n            this.ima.adsManager.resize(w, h, google.ima.ViewMode.FULLSCREEN);\n          } else {\n            this.ima.adsManager.resize(w, h, google.ima.ViewMode.NORMAL);\n          }\n        }\n      });\n    }\n\n    loadAds() {\n      if (this.vgCompanion) {\n        googletag.cmd.push(() => {\n          const adUnitPath = '/' + this.vgNetwork + '/' + this.vgUnitPath;\n          const slot = googletag.defineSlot(adUnitPath, this.vgCompanionSize, this.vgCompanion);\n\n          if (slot) {\n            slot.addService(googletag.companionAds());\n            slot.addService(googletag.pubads());\n            googletag.companionAds().setRefreshUnfilledSlots(true);\n            googletag.pubads().enableVideoAds();\n            googletag.enableServices();\n          }\n        });\n      }\n    }\n\n    onUpdateState(event) {\n      switch (event.type) {\n        case VgEvents.VG_PLAY:\n          if (!this.ima.adsLoaded) {\n            this.API.pause();\n            this.ima.adDisplayContainer.initialize();\n            this.requestAds(this.vgAdTagUrl);\n            this.ima.adsLoaded = true;\n          }\n\n          break;\n      }\n    }\n\n    requestAds(adTagUrl) {\n      // Show only to get computed style in pixels\n      this.show();\n      const adsRequest = new google.ima.AdsRequest();\n      const computedStyle = window.getComputedStyle(this.elem);\n      adsRequest.adTagUrl = adTagUrl;\n      adsRequest.linearAdSlotWidth = parseInt(computedStyle.width, 10);\n      adsRequest.linearAdSlotHeight = parseInt(computedStyle.height, 10);\n      adsRequest.nonLinearAdSlotWidth = parseInt(computedStyle.width, 10);\n      adsRequest.nonLinearAdSlotHeight = parseInt(computedStyle.height, 10);\n      this.ima.adsLoader.requestAds(adsRequest);\n    }\n\n    onAdsManagerLoaded(evt) {\n      this.show();\n      this.ima.adsManager = evt.getAdsManager(this.target);\n      this.processAdsManager(this.ima.adsManager);\n    } // @ts-ignore\n\n\n    processAdsManager(adsManager) {\n      const w = this.API.videogularElement.offsetWidth;\n      const h = this.API.videogularElement.offsetHeight; // Attach the pause/resume events.\n\n      this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, this.onContentPauseRequested.bind(this), false);\n      this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, this.onContentResumeRequested.bind(this), false);\n      this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, this.onSkippableStateChanged.bind(this), false);\n      this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.ALL_ADS_COMPLETED, this.onAllAdsComplete.bind(this), false);\n      this.ima.adsManager.addEventListener(google.ima.AdEvent.Type.COMPLETE, this.onAdComplete.bind(this), false);\n      this.ima.adsManager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError.bind(this), false);\n      this.ima.adsManager.init(w, h, google.ima.ViewMode.NORMAL);\n      this.ima.adsManager.start();\n    }\n\n    onSkippableStateChanged() {\n      const isSkippable = this.ima.adsManager.getAdSkippableState();\n\n      if (isSkippable) {\n        this.skipButton.style.display = 'block';\n      } else {\n        this.skipButton.style.display = 'none';\n      }\n    }\n\n    onClickSkip() {\n      this.ima.adsManager.skip();\n      this.onSkipAd.emit(true);\n    }\n\n    onContentPauseRequested() {\n      this.show();\n      this.API.pause();\n      this.onAdStop.emit(true);\n    }\n\n    onContentResumeRequested() {\n      this.API.play();\n      this.onAdStart.emit(true);\n      this.hide();\n    } // @ts-ignore\n\n\n    onAdError(evt) {\n      if (this.ima.adsManager) {\n        this.ima.adsManager.destroy();\n      }\n\n      this.hide();\n      this.API.play();\n      this.onAdStop.emit(true);\n    }\n\n    onAllAdsComplete() {\n      this.hide(); // The last ad was a post-roll\n\n      if (this.ima.adsManager.getCuePoints().join().indexOf('-1') >= 0) {\n        this.API.pause(); // it was stop() in Videogular v1\n\n        this.onAdStop.emit(true);\n      }\n    }\n\n    onAdComplete() {\n      // TODO: Update view with current ad count\n      this.ima.currentAd++;\n      this.onAdStop.emit(true);\n    }\n\n    show() {\n      window.dispatchEvent(new CustomEvent(VgEvents.VG_START_ADS));\n      this.displayState = 'block';\n    }\n\n    hide() {\n      window.dispatchEvent(new CustomEvent(VgEvents.VG_END_ADS));\n      this.displayState = 'none';\n    }\n\n    onContentEnded() {\n      this.ima.adsLoader.contentComplete();\n      this.onAdStop.emit(true);\n    }\n\n    onChangeFullscreen(fsState) {\n      if (!this.fsAPI.nativeFullscreen) {\n        this.isFullscreen = fsState;\n      }\n    }\n\n    onMissingGoogleImaLoader() {\n      this.hide();\n      this.API.play();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgImaAds.ɵfac = function VgImaAds_Factory(t) {\n    return new (t || VgImaAds)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI), i0.ɵɵdirectiveInject(VgFullscreenAPI));\n  };\n\n  VgImaAds.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgImaAds,\n    selectors: [[\"vg-ima-ads\"]],\n    hostVars: 2,\n    hostBindings: function VgImaAds_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.displayState);\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\",\n      vgNetwork: \"vgNetwork\",\n      vgUnitPath: \"vgUnitPath\",\n      vgCompanion: \"vgCompanion\",\n      vgCompanionSize: \"vgCompanionSize\",\n      vgAdTagUrl: \"vgAdTagUrl\",\n      vgSkipButton: \"vgSkipButton\"\n    },\n    outputs: {\n      onAdStart: \"onAdStart\",\n      onAdStop: \"onAdStop\",\n      onSkipAd: \"onSkipAd\"\n    },\n    decls: 1,\n    vars: 0,\n    consts: [[1, \"vg-ima-ads\"]],\n    template: function VgImaAds_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n    },\n    styles: [\"vg-ima-ads{position:absolute;width:100%;height:100%;z-index:300}vg-ima-ads .vg-ima-ads{position:absolute;width:100%;height:100%;pointer-events:none}\\n\"],\n    encapsulation: 2\n  });\n  return VgImaAds;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass Ima {\n  constructor(imaAdsElement) {\n    this.adDisplayContainer = new google.ima.AdDisplayContainer(imaAdsElement);\n    this.adsLoader = new google.ima.AdsLoader(this.adDisplayContainer);\n    this.adsManager = null;\n    this.adsLoaded = false;\n    this.currentAd = 0;\n  }\n\n} // tslint:disable:component-class-suffix\n\n\nlet VgOverlayPlay = /*#__PURE__*/(() => {\n  class VgOverlayPlay {\n    constructor(ref, API, fsAPI, controlsHidden) {\n      this.API = API;\n      this.fsAPI = fsAPI;\n      this.controlsHidden = controlsHidden;\n      this.isNativeFullscreen = false;\n      this.areControlsHidden = false;\n      this.subscriptions = [];\n      this.isBuffering = false;\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n      this.subscriptions.push(this.controlsHidden.isHidden.subscribe(this.onHideControls.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.bufferDetected.subscribe(isBuffering => this.onUpdateBuffer(isBuffering)));\n    }\n\n    onUpdateBuffer(isBuffering) {\n      this.isBuffering = isBuffering;\n    }\n\n    onChangeFullscreen(fsState) {\n      if (this.fsAPI.nativeFullscreen) {\n        this.isNativeFullscreen = fsState;\n      }\n    }\n\n    onHideControls(hidden) {\n      this.areControlsHidden = hidden;\n    }\n\n    onClick() {\n      const state = this.getState();\n\n      switch (state) {\n        case VgStates.VG_PLAYING:\n          this.target.pause();\n          break;\n\n        case VgStates.VG_PAUSED:\n        case VgStates.VG_ENDED:\n          this.target.play();\n          break;\n      }\n    }\n\n    getState() {\n      let state = VgStates.VG_PAUSED;\n\n      if (this.target) {\n        if (this.target.state instanceof Array) {\n          for (let i = 0, l = this.target.state.length; i < l; i++) {\n            if (this.target.state[i] === VgStates.VG_PLAYING) {\n              state = VgStates.VG_PLAYING;\n              break;\n            }\n          }\n        } else {\n          state = this.target.state;\n        }\n      }\n\n      return state;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgOverlayPlay.ɵfac = function VgOverlayPlay_Factory(t) {\n    return new (t || VgOverlayPlay)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI), i0.ɵɵdirectiveInject(VgFullscreenAPI), i0.ɵɵdirectiveInject(VgControlsHidden));\n  };\n\n  VgOverlayPlay.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VgOverlayPlay,\n    selectors: [[\"vg-overlay-play\"]],\n    hostVars: 2,\n    hostBindings: function VgOverlayPlay_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function VgOverlayPlay_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"is-buffering\", ctx.isBuffering);\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 2,\n    vars: 6,\n    consts: [[1, \"vg-overlay-play\"], [1, \"overlay-play-container\"]],\n    template: function VgOverlayPlay_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"native-fullscreen\", ctx.isNativeFullscreen)(\"controls-hidden\", ctx.areControlsHidden);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"vg-icon-play_arrow\", ctx.getState() !== \"playing\");\n      }\n    },\n    styles: [\"vg-overlay-play{z-index:200}vg-overlay-play.is-buffering{display:none}vg-overlay-play .vg-overlay-play{transition:all .5s;cursor:pointer;position:absolute;display:block;color:#fff;width:100%;height:100%;font-size:80px;filter:alpha(opacity=60);opacity:.6}vg-overlay-play .vg-overlay-play.native-fullscreen.controls-hidden{cursor:none}vg-overlay-play .vg-overlay-play .overlay-play-container.vg-icon-play_arrow{pointer-events:none;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;font-size:80px}vg-overlay-play .vg-overlay-play:hover{filter:alpha(opacity=100);opacity:1}vg-overlay-play .vg-overlay-play:hover .overlay-play-container.vg-icon-play_arrow:before{transform:scale(1.2)}\\n\"],\n    encapsulation: 2\n  });\n  return VgOverlayPlay;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgCoreModule = /*#__PURE__*/(() => {\n  class VgCoreModule {}\n\n  VgCoreModule.ɵfac = function VgCoreModule_Factory(t) {\n    return new (t || VgCoreModule)();\n  };\n\n  VgCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: VgCoreModule\n  });\n  VgCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [VgAPI, VgFullscreenAPI, VgUtils, VgControlsHidden, VgStates, VgEvents]\n  });\n  return VgCoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgImaAdsModule = /*#__PURE__*/(() => {\n  class VgImaAdsModule {}\n\n  VgImaAdsModule.ɵfac = function VgImaAdsModule_Factory(t) {\n    return new (t || VgImaAdsModule)();\n  };\n\n  VgImaAdsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: VgImaAdsModule\n  });\n  VgImaAdsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return VgImaAdsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgOverlayPlayModule = /*#__PURE__*/(() => {\n  class VgOverlayPlayModule {}\n\n  VgOverlayPlayModule.ɵfac = function VgOverlayPlayModule_Factory(t) {\n    return new (t || VgOverlayPlayModule)();\n  };\n\n  VgOverlayPlayModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: VgOverlayPlayModule\n  });\n  VgOverlayPlayModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return VgOverlayPlayModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:directive-class-suffix\n// tslint:disable:no-output-on-prefix\n// tslint:disable:no-string-literal\n\n\nlet VgDASH = /*#__PURE__*/(() => {\n  class VgDASH {\n    constructor(ref, API) {\n      this.ref = ref;\n      this.API = API;\n      this.onGetBitrates = new EventEmitter();\n      this.subscriptions = [];\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.vgFor = this.ref.nativeElement.getAttribute('vgFor');\n      this.target = this.API.getMediaById(this.vgFor);\n      this.createPlayer();\n    }\n\n    ngOnChanges(changes) {\n      if (changes['vgDash'] && changes['vgDash'].currentValue) {\n        this.createPlayer();\n      } else {\n        this.destroyPlayer();\n      }\n    }\n\n    createPlayer() {\n      if (this.dash) {\n        this.destroyPlayer();\n      } // It's a DASH source\n\n\n      if (this.vgDash && (this.vgDash.indexOf('.mpd') > -1 || this.vgDash.indexOf('mpd-time-csf') > -1)) {\n        let drmOptions;\n\n        if (this.vgDRMLicenseServer) {\n          drmOptions = this.vgDRMLicenseServer;\n\n          if (this.vgDRMToken) {\n            for (const drmServer in drmOptions) {\n              if (drmServer.hasOwnProperty(drmServer)) {\n                drmOptions[drmServer].httpRequestHeaders = {\n                  Authorization: this.vgDRMToken\n                };\n              }\n            }\n          }\n        }\n\n        this.dash = dashjs.MediaPlayer().create();\n        this.dash.getDebug().setLogToBrowserConsole(false);\n        this.dash.initialize(this.ref.nativeElement);\n        this.dash.setAutoPlay(false);\n        this.dash.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, () => {\n          const audioList = this.dash.getBitrateInfoListFor('audio');\n          const videoList = this.dash.getBitrateInfoListFor('video');\n\n          if (audioList.length > 1) {\n            audioList.forEach(item => item.qualityIndex = ++item.qualityIndex);\n            audioList.unshift({\n              qualityIndex: 0,\n              width: 0,\n              height: 0,\n              bitrate: 0,\n              mediaType: 'video',\n              label: 'AUTO'\n            });\n            this.onGetBitrates.emit(audioList);\n          }\n\n          if (videoList.length > 1) {\n            videoList.forEach(item => item.qualityIndex = ++item.qualityIndex);\n            videoList.unshift({\n              qualityIndex: 0,\n              width: 0,\n              height: 0,\n              bitrate: 0,\n              mediaType: 'video',\n              label: 'AUTO'\n            });\n            this.onGetBitrates.emit(videoList);\n          }\n        });\n\n        if (drmOptions) {\n          this.dash.setProtectionData(drmOptions);\n        }\n\n        this.dash.attachSource(this.vgDash);\n      } else {\n        if (this.target) {\n          this.target.pause();\n          this.target.seekTime(0);\n          this.ref.nativeElement.src = this.vgDash;\n        }\n      }\n    }\n\n    setBitrate(bitrate) {\n      if (this.dash) {\n        if (bitrate.qualityIndex > 0) {\n          if (this.dash.getAutoSwitchQualityFor(bitrate.mediaType)) {\n            this.dash.setAutoSwitchQualityFor(bitrate.mediaType, false);\n          }\n\n          const nextIndex = bitrate.qualityIndex - 1;\n          this.dash.setQualityFor(bitrate.mediaType, nextIndex);\n        } else {\n          this.dash.setAutoSwitchQualityFor(bitrate.mediaType, true);\n        }\n      }\n    }\n\n    destroyPlayer() {\n      if (this.dash) {\n        this.dash.reset();\n        this.dash = null;\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n      this.destroyPlayer();\n    }\n\n  }\n\n  VgDASH.ɵfac = function VgDASH_Factory(t) {\n    return new (t || VgDASH)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgDASH.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VgDASH,\n    selectors: [[\"\", \"vgDash\", \"\"]],\n    inputs: {\n      vgDash: \"vgDash\",\n      vgDRMToken: \"vgDRMToken\",\n      vgDRMLicenseServer: \"vgDRMLicenseServer\"\n    },\n    outputs: {\n      onGetBitrates: \"onGetBitrates\"\n    },\n    exportAs: [\"vgDash\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return VgDASH;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable:no-string-literal\n// tslint:disable:directive-class-suffix\n// tslint:disable:no-output-on-prefix\n\n\nlet VgHLS = /*#__PURE__*/(() => {\n  class VgHLS {\n    constructor(ref, API) {\n      this.ref = ref;\n      this.API = API;\n      this.vgHlsHeaders = {};\n      this.onGetBitrates = new EventEmitter();\n      this.subscriptions = [];\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.crossorigin = this.ref.nativeElement.getAttribute('crossorigin');\n      this.preload = this.ref.nativeElement.getAttribute('preload') !== 'none';\n      this.vgFor = this.ref.nativeElement.getAttribute('vgFor');\n\n      if (this.vgFor) {\n        this.target = this.API.getMediaById(this.vgFor);\n      } else {\n        this.target = this.API.getDefaultMedia();\n      }\n\n      this.config = {\n        autoStartLoad: this.preload\n      }; // @ts-ignore\n\n      this.config.xhrSetup = (xhr, url) => {\n        // Send cookies\n        if (this.crossorigin === 'use-credentials') {\n          xhr.withCredentials = true;\n        }\n\n        for (const key of Object.keys(this.vgHlsHeaders)) {\n          xhr.setRequestHeader(key, this.vgHlsHeaders[key]);\n        }\n      };\n\n      this.createPlayer();\n\n      if (!this.preload) {\n        this.subscriptions.push(this.API.subscriptions.play.subscribe(() => {\n          if (this.hls) {\n            this.hls.startLoad(0);\n          }\n        }));\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes['vgHls'] && changes['vgHls'].currentValue) {\n        this.createPlayer();\n      } else if (changes['vgHlsHeaders'] && changes['vgHlsHeaders'].currentValue) {// Do nothing. We don't want to create a or destroy a player if the headers change.\n      } else {\n        this.destroyPlayer();\n      }\n    }\n\n    createPlayer() {\n      if (this.hls) {\n        this.destroyPlayer();\n      } // It's a HLS source\n\n\n      if (this.vgHls && this.vgHls.indexOf('m3u8') > -1 && Hls.isSupported() && this.API.isPlayerReady) {\n        const video = this.ref.nativeElement;\n        this.hls = new Hls(this.config); // @ts-ignore\n\n        this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\n          const videoList = [];\n          videoList.push({\n            qualityIndex: 0,\n            width: 0,\n            height: 0,\n            bitrate: 0,\n            mediaType: 'video',\n            label: 'AUTO'\n          });\n          data.levels.forEach((item, index) => {\n            videoList.push({\n              qualityIndex: ++index,\n              width: item.width,\n              height: item.height,\n              bitrate: item.bitrate,\n              mediaType: 'video',\n              label: item.name\n            });\n          });\n          this.onGetBitrates.emit(videoList);\n        }); // @ts-ignore\n\n        this.hls.on(Hls.Events.LEVEL_LOADED, (event, data) => {\n          this.target.isLive = data.details.live;\n        });\n        this.hls.loadSource(this.vgHls);\n        this.hls.attachMedia(video);\n      } else {\n        if (this.target && !!this.target.pause) {\n          this.target.pause();\n          this.target.seekTime(0);\n          this.ref.nativeElement.src = this.vgHls;\n        }\n      }\n    }\n\n    setBitrate(bitrate) {\n      if (this.hls) {\n        this.hls.nextLevel = bitrate.qualityIndex - 1;\n      }\n    }\n\n    destroyPlayer() {\n      if (this.hls) {\n        this.hls.destroy();\n        this.hls = null;\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n      this.destroyPlayer();\n      delete this.hls;\n    }\n\n  }\n\n  VgHLS.ɵfac = function VgHLS_Factory(t) {\n    return new (t || VgHLS)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(VgAPI));\n  };\n\n  VgHLS.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VgHLS,\n    selectors: [[\"\", \"vgHls\", \"\"]],\n    inputs: {\n      vgHls: \"vgHls\",\n      vgHlsHeaders: \"vgHlsHeaders\"\n    },\n    outputs: {\n      onGetBitrates: \"onGetBitrates\"\n    },\n    exportAs: [\"vgHls\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return VgHLS;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgStreamingModule = /*#__PURE__*/(() => {\n  class VgStreamingModule {}\n\n  VgStreamingModule.ɵfac = function VgStreamingModule_Factory(t) {\n    return new (t || VgStreamingModule)();\n  };\n\n  VgStreamingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: VgStreamingModule\n  });\n  VgStreamingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return VgStreamingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-videogular\n */\n// Required for Ivy Build of Library\n// export * from './lib/buffering/vg-buffering';\n// export * from './lib/controls/vg-controls';\n// export * from './lib/controls/vg-fullscreen/vg-fullscreen';\n// export * from './lib/controls/vg-mute/vg-mute';\n// export * from './lib/controls/vg-play-pause/vg-play-pause';\n// export * from './lib/controls/vg-playback-button/vg-playback-button';\n// export * from './lib/controls/vg-volume/vg-volume';\n// export * from './lib/controls/vg-quality-selector/vg-quality-selector';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-buffering-time/vg-scrub-bar-buffering-time';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-cue-points/vg-scrub-bar-cue-points';\n// export * from './lib/controls/vg-scrub-bar/vg-scrub-bar-current-time/vg-scrub-bar-current-time';\n// export * from './lib/controls/vg-time-display/vg-time-display';\n// export * from './lib/controls/vg-track-selector/vg-track-selector';\n// export * from './lib/core/vg-player/vg-player';\n// export * from './lib/core/vg-media/vg-media';\n// export * from './lib/core/vg-cue-points/vg-cue-points';\n// export * from './lib/ima-ads/vg-ima-ads';\n// export * from './lib/overlay-play/vg-overlay-play';\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Ima, VgAPI, VgBuffering, VgBufferingModule, VgControls, VgControlsHidden, VgControlsModule, VgCoreModule, VgCuePoints, VgDASH, VgEvents, VgFullscreen, VgFullscreenAPI, VgHLS, VgImaAds, VgImaAdsModule, VgMedia, VgMediaElement, VgMute, VgOverlayPlay, VgOverlayPlayModule, VgPlayPause, VgPlaybackButton, VgPlayer, VgQualitySelector, VgScrubBar, VgScrubBarBufferingTime, VgScrubBarCuePoints, VgScrubBarCurrentTime, VgStates, VgStreamingModule, VgTimeDisplay, VgTrackSelector, VgUtcPipe, VgUtils, VgVolume }; //# sourceMappingURL=ngx-videogular.mjs.map","map":null,"metadata":{},"sourceType":"module"}